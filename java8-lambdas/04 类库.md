- 重点关注：java.util.function;

><T> the type of the input to the predicate  
public interface Predicate<T>   
Evaluates this predicate on the given argument.    
boolean test(T t);  
  
><T> the type of the input to the function   
<R> the type of the result of the function
 public interface Function<T, R>  
Applies this function to the given argument.  
R apply(T t);  

><T> the type of results supplied by this supplier  
public interface Supplier<T>  
Gets a result.  
T get();  

int是基本类型，Integer是装箱类型。基本类型内建在语言和运行环境中，是基本的程序构建模块；而装箱类型属于普通的 Java类，只不过是对基本类型的一种封装。
由于装箱类型是对象，因此在内存中存在额外开销。比如，整型在内存中占用4 字节，整型对象却要占用 16 字节。这一情况在数组上更加严重，整型数组中的每个元素只占用基本类型的内存，而整型对象数组中，每个元素都是内存中的一个指针，指向 Java堆中的某个对象。在最坏的情况下，同样大小的数组， Integer[] 要比 int[] 多占用 6 倍内存。

BinaryOperator 是一种特殊的 BiFunction 类型，参数的类型和返回值的类型相同。比如，两个整数相加就是一个 BinaryOperator 。

使用 Java 1 到 Java 7 编译的类库或应用，可以直接在 Java 8 上运行。Java 8 中为Collection 接口增加了 stream 方法，这意味着所有实现了 Collection 接口的类都必须增加这个新方法。但这个修改依然打破了二进制兼容性，要避免这个糟糕情况，则需要在 Java 8 中添加新的语言特性：默认方法

Java 8 通过默认方法解决该问题： Collection 接口告诉它所有的子类：
“如果你没有实现 stream 方法，就使用我的吧。 ”
主要是由增加默认方法的目的决定的，增加默认方法主要是为了在接口上向后兼容。让类中重写方法的优先级高于默认方法能简化很多继承问题。

>三定律
如果对默认方法的工作原理，特别是在多重继承下的行为还没有把握，如下三条简单的定
律可以帮助大家。
>>1. 类胜于接口。如果在继承链中有方法体或抽象的方法声明，那么就可以忽略接口中定义
的方法。
>>2. 子类胜于父类。如果一个接口继承了另一个接口，且两个接口都定义了一个默认方法，
那么子类中定义的方法胜出。
>>3. 没有规则三。如果上面两条规则不适用，子类要么需要实现该方法，要么将该方法声明
为抽象方法。  
其中第一条规则是为了让代码向后兼容。


Stream 是个接口，Stream.of是接口的静态方法。

Optional 是为核心类库新设计的一个数据类型，用来替换 null 值
使用工厂方法of ，可以从某个值创建出一个 Optional 对象。 Optional 对象相当于值的容器，而该值可以通过 get 方法提取。
Optional的empty、ofNullable、isPresent、orElse、orElseGet方法。