>软件开发最重要的设计工具不是什么技术，而是一颗在设计原则方面训练有素的头脑。—— Craig Larman

## 1. Lambda表达式改变了设计模式
>设计模式是软件架构中解决通用问题的模板，它将解决特定问题的最佳实践途径固定了下来。以下为可被 Lambda 表达式简化和改进的行为模式：
- 命令者模式
>命令者是一个对象，它封装了调用另一个方法的所有细节。命令者模式有四个类参与其中：客户端->创建发起者->调用命令者，客户端->使用具体命令者->实现命令者 or 调用命令接收者。
>>①客户端：创建具体的命令者实例；②发起者：控制一个或多个命令的顺序和执行；③命令者：封装了所有调用命令执行者的信息；④命令接收者:执行实际任务。

如何使用 Lambda 表达式改进该模式？
>假设有一个GUI  Editor 组件，可执行 open 、 save 等一系列操作,想实现宏功能——可将一系列操作录制下来(命令接收者)。

```Java  
//文本编辑器可能具有的一般功能，包含命令操作
public interface Editor {
    public void save();

    public void open();

    public void close();
}
//统一接口概况这些操作，所有操作均实现 Action 接口
//【在核心 Java 中，已经有一个和 Action 接口结构一致的函数接口—— Runnable】
public interface Action {
    public void perform();
}
//保存操作代理给 Editor 方法，save 方法对应 Save 类(命令对象)
public class Save implements Action {
    private final Editor editor;

    public Save(Editor editor) {
        this.editor = editor;
    }

    @Override
    public void perform() {
        editor.save();
    }
}
//打开文件操作代理给 Editor 方法，open方法对应 Open类(命令对象)
public class Open implements Action {
    private final Editor editor;

    public Open(Editor editor) {
        this.editor = editor;
    }

    @Override
    public void perform() {
        editor.open();
    }
}
//包含操作序列的宏，可按顺序执行操作
public class Macro {
    private final List<Action> actions;

    public Macro() {
        actions = new ArrayList<>();
    }

    public void record(Action action) {
        actions.add(action);
    }

    public void run() {
        actions.forEach(Action::perform);
    }
}
//使用命令者模式构建宏
@Test 
public void classBasedCommand() {
    MockEditor editor = new MockEditor();
    Macro macro = new Macro();
    macro.record(new Open(editor));
    macro.record(new Save(editor));
    macro.record(new Close(editor));
    macro.run();
    assertEquals("open", actions.get(0));
    assertEquals("save", actions.get(1));
    assertEquals("close", actions.get(2));
}

```

>事实上，所有的命令类， Save 、 Open 都是 Lambda 表达式，只是暂时藏在类的外壳下。它们是一些行为，我们通过创建类将它们在对象之间传递。Lambda 表达式能让这个模式变得非常简单，我们可以扔掉这些类。
```java  
//使用 Lambda 表达式构建宏
Macro macro = new Macro();
macro.record(() -> editor.open());
macro.record(() -> editor.save());
macro.record(() -> editor.close());
macro.run();
...

//使用方法引用将命令和宏对象关联起来
//使用方法引用构建宏
Macro macro = new Macro();
macro.record(editor::open);
macro.record(editor::save);
macro.record(editor::close);
macro.run();
```
>使用Lambda 表达式或方法引用，让代码更简洁，去除大量样板代码。
>>命令者模式被大量用在实现组件化的图形界面系统、撤销功能、线程池、事务和向导中。

- 策略模式
>主要思想：定义一个通用问题，用不同算法实现，将这些算法都封装在一个统一接口背后。
eg.文件压缩：提供给用户各种压缩文件的方式。步骤：压缩器->调用压缩策略，zip压缩 or gzip压缩->实现压缩策略。
```java  
//定义压缩数据的策略接口
public interface CompressionStrategy {
    OutputStream compress(OutputStream data) throws IOException;
}

//使用 gzip 算法压缩数据
public class ZipCompressionStrategy implements CompressionStrategy {
    @Override
    public OutputStream compress(OutputStream data) throws IOException {
        return new ZipOutputStream(data);
    }
}

//使用 zip 算法压缩数据
public class GzipCompressionStrategy implements CompressionStrategy {
    @Override
    public OutputStream compress(OutputStream data) throws IOException {
        return new GZIPOutputStream(data);
    }
}

//在构造类时提供压缩策略，使用策略模式的地方。该类compress方法，读入文件，压缩后输出。
//它的构造函数有一个 CompressionStrategy 参数，调用代码可以在运行期使用该参数决定使用哪种压缩策略。
public class Compressor {
    private final CompressionStrategy strategy;

    public Compressor(CompressionStrategy strategy) {
        this.strategy = strategy;
    }

    public void compress(Path inFile, File outFile) throws IOException {
        try (OutputStream outStream = new FileOutputStream(outFile)) {
            Files.copy(inFile, strategy.compress(outStream));
        }
    }
}

//传统的策略模式实现方式
//使用具体的策略类初始化 Compressor
public static void classBasedExample(Path inFile, File outFile) throws IOException {
    Compressor gzipCompressor = new Compressor(new GzipCompressionStrategy());
    gzipCompressor.compress(inFile, outFile);

    Compressor zipCompressor = new Compressor(new ZipCompressionStrategy());
    zipCompressor.compress(inFile, outFile);
}

//使用 Lambda表达式或者方法引用可以去掉样板代码
//可以完全舍弃 GzipCompressionStrategy和ZipCompressionStrategy 类
//使用方法引用初始化 Compressor
public static void lambdaBasedExample(Path inFile, File outFile) throws IOException {
    Compressor gzipCompressor = new Compressor(GZIPOutputStream::new);
    gzipCompressor.compress(inFile, outFile);

    Compressor zipCompressor = new Compressor(ZipOutputStream::new);
    zipCompressor.compress(inFile, outFile);
}
```
- 观察者模式
>观察者模式被大量应用于基于 MVC 的 GUI 工具中，以此让模型状态发生变化时，自动刷新视图模块，达到二者之间的解耦。
```java  
//【观察者】用于观察登陆到月球的组织的接口
public interface LandingObserver {
    void observeLanding(String name);
}

//【被观察者】月球
public class Moon {
    private final List<LandingObserver> observers = new ArrayList<>();

    public void land(String name) {
        for (LandingObserver observer : observers) {
            observer.observeLanding(name);
        }
    }
    public void startSpying(LandingObserver observer) {
        observers.add(observer);
    }
}

//外星人观察到人类登陆月球
public class Aliens implements LandingObserver {
    @Override
    public void observeLanding(String name) {
        if (name.contains("Apollo")) {
            System.out.println("They're distracted, lets invade earth!");
        }
    }
}

//NASA也能观察到有人登陆月球
public class Nasa implements LandingObserver {
    @Override
    public void observeLanding(String name) {
        if (name.contains("Apollo")) {
            System.out.println("We made it!");
        }
    }
}
```
>传统的，用户代码需要有一层模板类，使用 Lambda 表达式，就不用编写这些类了。
```java  
//使用类的方式构建用户代码
private static void classBasedExample() {
    Moon moon = new Moon();
    moon.startSpying(new Nasa());
    moon.startSpying(new Aliens());

    moon.land("An asteroid");
    //none
    moon.land("Apollo 11");
    //We made it!
    //They're distracted, lets invade earth!
}

//使用 Lambda 表达式构建用户代码
private static void lambdaBasedExample() {
    Moon moon = new Moon();
    
    moon.startSpying(name -> {
        if (name.contains("Apollo"))
            System.out.println("We made it!");
    });
    
    moon.startSpying(name -> {
        if (name.contains("Apollo"))
            System.out.println("They're distracted, lets invade earth!");
    });
    
    moon.land("An asteroid");
    moon.land("Apollo 11");
}
```

>将大量代码塞进一个方法会让可读性变差是决定如何使用Lambda表达式的黄金法则（也是编写一般方法的黄金法则）。

- 模板方法模式
>整体算法的设计是一个抽象类，它有一系列抽象方法，代表算法中可被定制的步骤，同时这个类中包含了一些通用代码。

```Java  
//使用模板方法模式描述申请贷款过程
public abstract class LoanApplication {
    public void checkLoanApplication() throws ApplicationDenied {
        checkIdentity();
        checkCreditHistory();
        checkIncomeHistory();
        reportFindings();
    }

    protected abstract void checkIdentity() throws ApplicationDenied;

    protected abstract void checkIncomeHistory() throws ApplicationDenied;

    protected abstract void checkCreditHistory() throws ApplicationDenied;

    private void reportFindings() {
    }
}

//公司
public class CompanyLoanApplication extends LoanApplication {
    @Override
    protected void checkIdentity() {
    }

    @Override
    protected void checkIncomeHistory() {
    }

    @Override
    protected void checkCreditHistory() {
    }
}

//个人
public class PersonalLoanApplication extends LoanApplication {
    @Override
    protected void checkIdentity() {
    }

    @Override
    protected void checkIncomeHistory() {
    }

    @Override
    protected void checkCreditHistory() {
    }
}

//雇员
public class EmployeeLoanApplication extends PersonalLoanApplication {
    @Override
    protected void checkIncomeHistory() {
        // They work for us!
    }
}
```

>模板方法模式:将一组方法调用按一定顺序组织起来。若用函数接口表示函数，用Lambda表达式或方法引用 实现这些接口，比用继承构建算法，更灵活。

```java  
//员工申请贷款的例子
//无抽象方法，而是多出一些属性（都实现了函数接口 Criteria）
public class LoanApplication {
    private final Criteria identity;
    private final Criteria creditHistory;
    private final Criteria incomeHistory;

    public LoanApplication(Criteria identity, Criteria creditHistory, Criteria incomeHistory) {
        this.identity = identity;
        this.creditHistory = creditHistory;
        this.incomeHistory = incomeHistory;
    }

    public void checkLoanApplication() throws ApplicationDenied {
        identity.check();
        creditHistory.check();
        incomeHistory.check();
        reportFindings();
    }

    private void reportFindings() {
    }
}

//如果申请失败，函数接口 Criteria 抛出异常
public interface Criteria {
    void check() throws ApplicationDenied;
}

```
>不基于继承的模式:不需在 LoanApplication及其子类中实
现算法，分配功能时更灵活。eg.让 Company 类负责所有的检查，那么 Company 类就会多出一系列方法。现在只需为CompanyLoanApplication 类传入对应的方法引用。

```Java  
// Company 类中的检查方法
public class Company {
    public void checkIdentity() throws ApplicationDenied {
    }

    public void checkProfitAndLoss() throws ApplicationDenied {
    }

    public void checkHistoricalDebt() throws ApplicationDenied {
    }
}
//CompanyLoanApplication 类声明了对应的检查方法
public class CompanyLoanApplication extends LoanApplication {
    public CompanyLoanApplication(Company company) {
        super(company::checkIdentity, company::checkHistoricalDebt, company::checkProfitAndLoss);
    }
}
```

## 2. Lambda表达式的领域专用语言
>领域专用语言（DSL） 分为两类：内部 DSL (eg. JMock 和 Mockito、用sql构建API等。从某种角度上说，内部 DSL 就是普通的类库，提供 API 方便使用)和外部 DSL(脱离代码编写，eg.级联样式表（CSS）和正则表达式)。
>>行为驱动开发（BDD）的 DSL：LambdaBehave。BDD 是测试驱动开发（TDD）的一个变种，它的重点是描述程序的行为，而非一组需要通过的单元测试。

- 使用Java编写DSL

- 实现

- 评估
## 3. Lambda表达式的SOLID原则
- 单一功能原则
- 开闭原则
- 依赖反转原则