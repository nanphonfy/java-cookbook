## 1. 并行和并发
两者概念不同，作用不同。  
>并发：两任务共享时间段，核1->任务1->任务2；  
并行：两任务同一时间发生，eg.运行在多核CPU，核1->任务1+核2>任务2
>>数据并行化：将数据分块，单独分配处理单元。大数据量时，将问题分解为可在多块数据上求解的形式，每块执行运算，最后汇总各块的结果。与顺序执行相比，并行化时CPU承载工作量更大。  

任务并行化VS数据并行化  
任务并行化：线程不同，工作各异，eg.Java EE应用容器。

## 2. 为何要并行化
>如今多核处理器，物理单元搭载32或64核已不鲜见。不能再依托CPU时钟频率来提升处理速度，结合现代CPU架构编写并行化代码。
>>阿姆达定律：问题的求解时间将完全取决于可被分解为几部分，优化任何计算相关(不是所有任务都和计算有关)的任务->如何有效利用现有硬件的问题。

## 3. 并行化流操作
stream().parallel()或parallelStream()
>运行速度：并行化VS串行化  
取决于机器环境、输入流的大小、核的数量、编写的代码。打类比：4核，10专辑，v(串行)=8v(并行)；100专辑，v(串行)=v(并行)；10000专辑，2.5v(串行)=v(并行)。

## 4. 模拟掷骰子
**掷两次骰子，求点数之和。**  
①求组合，eg.掷2点概率1/36；②蒙特卡洛模拟，尽可能多的模拟次数。

```Java 
//使用流的并行化模拟
private static final int N = 100000000;
public Map<Integer, Double> parallelDiceRolls() {
double fraction = 1.0 / N;
return IntStream.range(0, N)                        // <1>
        .parallel()                         // <2>
        .mapToObj(twoDiceThrows())          // <3>
        .collect(groupingBy(side -> side,   // <4>
                summingDouble(n -> fraction))); // <5>
}
private static IntFunction<Integer> twoDiceThrows() {
    return i -> {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        int firstThrow = random.nextInt(1, 7);
        int secondThrow = random.nextInt(1, 7);
        return firstThrow + secondThrow;
    };
}
```


```Java 
//手动使用线程模拟
public class ManualDiceRolls {
    private static final int N = 100000000;

    private final double fraction;
    private final Map<Integer, Double> results;
    private final int numberOfThreads;
    private final ExecutorService executor;
    private final int workPerThread;

    public static void main(String[] args) {
        ManualDiceRolls roles = new ManualDiceRolls();
        roles.simulateDiceRoles();
    }

    public ManualDiceRolls() {
        fraction = 1.0 / N;
        results = new ConcurrentHashMap<>();
        numberOfThreads = Runtime.getRuntime().availableProcessors();
        executor = Executors.newFixedThreadPool(numberOfThreads);
        workPerThread = N / numberOfThreads;
    }

    public void simulateDiceRoles() {
        List<Future<?>> futures = submitJobs();
        awaitCompletion(futures);
        printResults();
    }

    private void printResults() {
        results.entrySet()
               .forEach(System.out::println);
    }

    private List<Future<?>> submitJobs() {
        List<Future<?>> futures = new ArrayList<>();
        for (int i = 0; i < numberOfThreads; i++) {
            futures.add(executor.submit(makeJob()));
        }
        return futures;
    }

    private Runnable makeJob() {
        return () -> {
            ThreadLocalRandom random = ThreadLocalRandom.current();
            for (int i = 0; i < workPerThread; i++) {
                int entry = twoDiceThrows(random);
                accumulateResult(entry);
            }
        };
    }

    private void accumulateResult(int entry) {
        results.compute(entry, (key, previous) ->
            previous == null ? fraction
                             : previous + fraction
        );
    }

    private int twoDiceThrows(ThreadLocalRandom random) {
        int firstThrow = random.nextInt(1, 7);
        int secondThrow = random.nextInt(1, 7);
        return firstThrow + secondThrow;
    }

    private void awaitCompletion(List<Future<?>> futures) {
        futures.forEach((future) -> {
            try {
                future.get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        executor.shutdown();
    }
}
```



