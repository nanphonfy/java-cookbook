### 1 从外部迭代到内部迭代
>Java8以前，用for循环迭代集合类时，存在如下问题：
>- 要写很多样板代码；
>- 将for 循环改造成并行方式运行也很麻烦，需要修改每个 for 循环才能实现；
>- for 循环的样板代码模糊了代码的本意。

for 循环封装了迭代的语法糖,工作原理为：
首先调用 iterator 方法，产生一个新的 Iterator 对象，进而控制整个迭代过程，这就是外部迭代。迭代过程通过显式调用 Iterator 对象的 hasNext 和 next
方法完成迭代。

```
int count = 0;
Iterator<Artist> iterator = allArtists.iterator();
while(iterator.hasNext()) {
    Artist artist = iterator.next();
    if (artist.isFrom("London")) {
        count++;
    }
}
```
外部迭代很难抽象出不同的操作；本质上是串行化操作。使用 for 循环会将行为和方法混为一谈。

>Java8，可采用内部迭代。stream() 方法的调用iterator() 的作用一样。该方法不是返回一个控制迭代的 Iterator 对象，而是返回内部迭代中的相应接口： Stream(Stream 是用函数式编程方式在集合类上进行复杂操作的工具)

```
long count = allArtists.stream().filter(
artist ->artist.isFrom("London")).count();
//类库设计精妙，只需对列表迭代一次。

allArtists.stream().filter(artist -> {
System.out.println(artist.getName());
return artist.isFrom("London");
});
//上述filter方法的等价写法
```
### 2 实现机制
>通常，在Java中调用一个方法，计算机会随即执行操作，Stream却略有不同，内部虽是
普通的 Java 方法，但返回的 Stream 对象却不是一个新集合，而是创建新集合的配方。

**判断惰性求值、及早求值：看返回值。**
- 如果返回值是 Stream，那么是惰性求值；
- 如果返回值是另一个值或为空，那么就是及早求值。

>filter只刻画了Stream，没产生新集合。只描述Stream ，最终不产生新集合的方法叫作惰性求值方法；而count 最终会从 Stream 产生值的方法叫作及早求值方法。形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果。
整个过程和建造者模式有共通之处。建造者模式使用一系列操作设置属性和配置，最后调用一个 build 方法，这时，对象才被真正创建。这也意味着
可以在集合类上级联多种操作，但迭代只需一次。

### 3 常用流
①collect(toList())
>由 Stream 里的值生成一个列表，是一个及早求值操作。
>> 由于很多 Stream 操作都是惰性求值，因此调用 Stream 上一系列方法之后，还需要最后再
调用一个类似 collect 的及早求值方法

②map
>将一个流中的值转换成一个新的流
>>传给 map的 Lambda 表达式只接受一个 String 类型的参数，返回一个新的 String 。参数
和返回值不必属于同一种类型，但是 Lambda 表达式必须是 Function 接口的一个实例，`T-Function-R`

```
//示例
List<String> collected = new ArrayList<>();
for (String string : asList("a", "b", "hello")) {
    String uppercaseString = string.toUpperCase();
    collected.add(uppercaseString);
}
//类比
List<String> collected = Stream.of("a", "b","hello").map(string -> string.toUpperCase())
.collect(toList());
```
③filter  
>遍历数据并检查其中的元素时
>>filter 接受一个函数作为参数，该函数用Lambda 表达式表示。当Lambda 表达式值为 true 的元素被保留下来，`T-Predicate-boolean`

```
//示例
List<String> beginningWithNumbers = new ArrayList<>();
for(String value : asList("a", "1abc", "abc1")) {
    if (isDigit(value.charAt(0))) {
        beginningWithNumbers.add(value);
    }
}
//类比
List<String> beginningWithNumbers
= Stream.of("a", "1abc", "abc1").filter(value ->isDigit(value.charAt(0)))
.collect(toList());

```
④flatMap
>可用 Stream 替换值，然后将多个 Stream 连接成一个 Stream
>> 有时，用户希望让 map操作有点变化，生成一个新的 Stream 对象取而代之。flatMap 方法的相关函数接口和 map 方法的一样，都是 Function接口，只是方法的返回值限定为 Stream 类型罢了。

```
List<Integer> together = Stream.of(asList(1, 2), asList(3, 4)).flatMap(numbers -> numbers.stream())
.collect(toList());
```
⑤ max 和 min
>Java 8 在Comparator 提供了一个新的静态方法 comparing，花点时间研究一下 comparing 方法是值得的。实际上这个方法接受一个函数并返回另一个函数。此外，还可以调用空 Stream 的 max 方法，返回 Optional 对象。
```
//示例
List<Track> tracks = asList(new Track("Bakai", 524),new Track("Violets for Your Furs", 378),new Track("Time Was", 451));
Track shortestTrack = tracks.stream().min(Comparator.comparing(track -> track.getLength())).get();
assertEquals(tracks.get(1), shortestTrack);
```
⑥combine
>返回当前元素和 accumulator中较短的那个
>>max 和 min 方法都属于更通用的一种编程模式。
调用 combine 函数，拿accumulator和集合中的每一个元素做运算，再将运算结果赋给 accumulator ，最后返回accumulator的值.

```
//示例，使用 for 循环查找最短曲目
Track shortestTrack = tracks.get(0);
for (Track track : tracks) {
    if (track.getLength()<shortestTrack.getLength){
    shortestTrack = track;
    }
}
//类比，reduce 模式
Object accumulator = initialValue;
for(Object element : collection) {
    accumulator = combine(accumulator, element);
}
```
⑦reduce
>reduce 实现从一组值中生成一个值。count 、 min 和 max 方法，因常用而被纳入标准库，它们都是 reduce 操作。
>>Lambda表达式为reducer，reducer的类型为BinaryOperator，以下示例有函数式编程和命令式编程
的区别。
*注：在生产环境应使用另外一种标准类库内置的求和方法。*
```
//使用 reduce 求和
int count = Stream.of(1, 2, 3).reduce(0, (acc, element) -> acc + element);//6
//展开 reduce 操作
BinaryOperator<Integer> accumulator = (acc,element) -> acc + element;
int count = accumulator.apply(accumulator.apply(acumulator.apply(0, 1),2),3);
//命令式编程方式求和
int acc = 0;
for (Integer element : asList(1, 2, 3)) {
    acc = acc + element;
}
```
⑧整合操作  
**问题：**找出某张专辑上所有乐队的国籍。(艺术家列表里既有个人，也有乐队，乐队一般以'The'开头)  
**思路：**
1. 找出专辑上的所有表演者；
2. 分辨出哪些表演者是乐队；
3. 找出每个乐队的国籍；
4. 将找出的国籍放入一个集合。

```
Set<String> origins = album.getMusicians().filter(artist ->artist.getName().startsWith("The"))
.map(artist -> artist.getNationality()).collect(toSet());
```
>- getMusicians 、filter 和 map 方法都返回 Stream 对象，属于惰性求值，collect方法属于及早求值。
> - 通过Stream暴露集合的最大优点在于，它很好地封装了内部实现的数据结构。仅暴露一个Stream接口，用户在实际操作中无论如何使用，都不会影响内部的 List 或 Set 。在编程中使用更现代的 Java 8 风格。











