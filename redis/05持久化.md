## 1 介绍
>Redis支持RDB和AOF两种持久化机制，持久化有效避免因进程退出数据丢失问题，重启时利用之前持久化的文件即可实现数
据恢复。
## 2 RDB
>RDB持久化把当前进程数据生成快照保存到硬盘，代表Redis在某个时间点上的数据快照，RDB有手动和自动触发。
- 手动触发
>- save：阻塞服务器，直到RDB完成,*已弃用*；
>- bgsave：Redis进程fork出子进程，RDB持久化过程由子进程负责，完成后自动结束。Redis内部的RDB都采用bgsave。
- 自动触发
>内部自动触发RDB持久化有：①`save m n`配置(m秒内存在n次修改，自动触发`bgsave`);②从节点执行全量复制，主节点自动执行`bgsave`，生成文件发往从节点;③`debug reload`自动触发'save';④默认下`shutdown`，若没开启AOF，自动执行`bgsave`。

### 2.1 bgsave是主流的触发RDB持久化方式
流程如下：
`bgsave->父进程->fork->子进程->生成RDB文件->父进程`
>1. 执行bgsave，Redis父进程判断是否有正在执行的子进程(eg.RDB/AOF子进程)，存在则直接返回；
>2. 父进程fork创建子进程，fork过程中父进程会阻塞(`info stats`查看`latest_fork_usec`，最近一个fork操作耗时-微秒）；
>3. fork完成后，`bgsave`返回“Background saving started”,不再阻塞父进程，可继续响应其他命令；
>4. 子进程创建RDB文件，根据父进程内存 生成 **临时快照文件**，完成后对原有文件进行原子替换(`lastsave`的rdb_last_save_time,最后一次生成RDB的时间)；
>5. 信号通知父进程，以更新统计信息。

>配置文件的dir：RDB文件保存目录，dbfilename：其文件名。
>>坏盘或磁盘写满时，在线修改config set dir{newDir}到新的可用磁盘路径,然后bgsave磁盘切换(RDB、AOF都适用)。
同理，可在线config set dbfilename{newFileName}。  
>Redis默认采用LZF算法压缩RDB文件，远远小于内存数据，消耗CPU但大幅↓文件体积，方便保存或网络传输，线上建议开启（默认开）。(config set rdbcompression{yes|no})
### 2.2 优缺点
**优：** ①紧凑压缩的二进制文件，可每X小时执行bgsave备份，灾难恢复；②加载RDB恢复数据远远快于AOF。  
**缺：** ①无法实时持久化（bgsave每次都要fork建子进程，重量级操作）；②特定二进制格式，新旧版不兼容。

## 3 AOF
>AOF（append only file）持久化，日志 记录每次写命令，重启时再重新执行AOF文件中的命令，恢复数据。它解决了数据持久化的实时性。理解掌握好其机制，↑兼顾数据安全性和性能。  
>>开启AOF：`appendonly yes`(默认不开启)  
AOF文件名：`appendfilename`(默认文件名appendonly.aof)  
保存路径：dir(同RDB)  
### 3.1 **AOF是Redis持久化的主流方式**  
AOF工作流程：
`命令写入（append）->AOF缓冲->文件同步（sync）->AOF文件->文件重写（rewrite）<-重启加载（load）`
>1. 所有的写入命令会追加到aof_buf（缓冲区）;
>1. AOF缓冲区根据对应的策略向硬盘做同步操作;
>1. 随着AOF文件越来越大，需定期对AOF文件进行重写，达到压缩目的;
>1. 当Redis服务器重启时，可加载AOF文件进行数据恢复。
- 命令写入  
>AOF直接采用文本协议格式
>>①文本协议兼容性很好；②开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销；③可读性，方便直接修改和处理。

>AOF为何把命令追加到aof_buf（缓冲区）？
>>①Redis单线程响应命令，直接追加到硬盘，性能完全取决于当前硬盘负载；②可提供多种缓冲区同步硬盘的策略，在性能和安全性做平衡。
- 文件同步  
>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制。
>>always:不建议配置。每次写入都要同步，代价高；  
no:性能↑，但数据安全性无法保证；  
everysec:  建议配置，默认配置。兼顾性能和数据安全性。理论上系统突然宕机会丢失1秒数据。

- 重写机制
- 重启加载
- 文件校验