>java编译后成为字节码，被类加载器加载到JVM，最终需转化为汇编指令在CPU执行，其并发机制依赖于JVM和CPU指令。

### 1 volatile应用
>volatile是轻量级synchronized（多处理器保证共享变量的可见性），使用恰到时，比synchronized使用和执行成本更低（不会引起上下文切换和调度）。

#### 1.1 volatile定义与实现原理
>volatile定义：

- 实现原理相关的CPU术语和说明  

术语 | 描述
---|---
内存屏障| 一组处理器指令（限制内存操作顺序）
缓冲行 | 缓存最小存储单元
原子操作 | 不可中断的一个或一系列操作
缓存行填充| 识别到内存操作数可缓存，读取缓存行到适当缓存（L1、L2、L3或all）
缓存命中 | 缓存行填充的内存位置仍是下次处理器访问的，直接从缓存读
写命中 | 处理器将操作数写回，若缓存内存地址在缓存行（有效），则处理器写回缓存（而非内存）
写缺失 | 一个有效缓存行被写入不存在的内存区域

- volatile如何保证可见性
>其汇编代码的Lock前缀：  
>- ①将当前处理器缓存行数据写回系统内存（一般不锁总线，锁缓存[缓存锁定]）；
>- ②使其他CPU缓存该地址的数据无效（下次访问相同内存地址时，强制缓存行填充）。

为提升速度：处理器先将系统内存数据读到内部缓存（L1、L2...）。若对volatile变量写，JVM发送Lock前缀指令，将该变量所在缓存行写回到系统内存。  
>多处理器下，为保证各个处理器的缓存一致，实现缓存一致性协议。每个处理器嗅探总线传播的数据，检查缓存是否过期：若处理器发现缓存行的内存地址被修改，会把当前缓存行置无效，重新从系统内存读取。

#### 1.2 volatile的优化
- volatile使用优化
>追加字节能优化性能。一个对象引用占4字节，追加15个变量+父类一共64字节。因为对于很多处理器的L1、L2、L3缓存的高速缓存行是64字节宽，不支持部分填充缓存行（若队列头结点和尾结点都不足64行，可能会被读入同一个缓存行）。多处理器下都会缓存同样的头、尾节点，当一个处理器修改头结点时，将整个缓存行锁定，导致其他处理器不能访问自己高速缓存中的尾节点。且队列的出、入队需不停修改头、尾节点，多处理器下将严重影响性能。追加到64字节，避免了头结点和尾节点加载到同一个缓存行，头、尾不会互相锁定。

- 不适用场景
>①缓存行非64字节宽的处理器；  
②共享变量不会被频繁写（不频繁写，锁的概率很小，追加字节处理器需读更多字节到高速缓冲区，带来性能消耗）。

### 2 synchronized的实现原理与应用  
>java 1.6为减少synchronized获得锁和释放锁带来的性能消耗引入偏向锁和轻量级锁，及锁的存储结构和升级过程。

>- 同步基础：java每个对象都可作为锁。  
>>①普通同步方法（锁当前实例对象）；  
②静态同步方法（当前类的Class对象）；  
③同步方法块（锁synchronized口号里配置的对象）。

>JVM基于进入和退出monitor对象来实现方法同步和代码块同步。  
代码块同步使用monitorenter和monitorexit指令，方法同步使用其他方式（也可用这两指令实现）。

#### 2.1 java对象头
- java对象头的长度   

长度 | 内容| 说明
---|---|---
 32/64bit| mark word| 存储对象hashcode或锁信息
 32/64bit| class metadata address| 存储到对象类型数据的指针
 32/64bit| array length| 数组长度

- java对象头的存储结构    
>mark word默认存储对象的hashcode、分代年龄和锁标记位。

锁状态 | 25bit| 4bit| 1bit是否是偏向锁| 2bit锁标志位
---|---|---|---|---
 无锁状态| 对象的hashcode| 对象分代年龄 |0 |01 

- 32位mark word的状态变化  
>运行期间，mark word存储数据会随标志位变化而变化

锁状态 | 25bit| 4bit| 1bit是否是偏向锁| 2bit锁标志位
---|---|---|---|---
轻量级锁| 指向栈中锁记录的指针| | |00
重量级锁| 指向互斥量（重量级锁）的指针| | |10
GC标记| 空| | |11
偏向锁| 线程id、epoch| 对象分代年龄 |1 |01 

- 64位mark word的存储结构  

锁状态 | 25bit| 31bit| 1bit cms_free| 4bit 分代年龄| 1bit 偏向锁| 2bit 锁标志位
---|---|---|---|---|---|---
无锁| unused|hashcode | | | 0| 01
偏向锁| 线程id（54bit）、epoch（2bit）| | | |1 |01 

#### 2.2 锁的升级与对比
- 锁4种状态级别：  
`无锁<偏向锁<轻量级锁<重量级锁`    
为提高获得锁和释放锁的效率，锁升级不能降级。

- 偏向锁

- 轻量级锁

- 锁的优缺点对比

锁状态 | 优点| 缺点| 适应场景
---|---|---|---
偏向锁| 加锁和解锁不需额外消耗，和非同步方法相当| 线程间的锁竞争带来额外的锁撤销消耗| 适用只有一个线程访问同步块场景
轻量级锁| 竞争线程不会阻塞，提高响应|若得不到锁竞争的线程，自旋消耗CPU| 追求响应，同步块执行非常快
重量级锁|线程竞争不使用自旋，不消耗CPU| 线程阻塞，响应时间慢| 追求吞吐，同步块执行速度较长