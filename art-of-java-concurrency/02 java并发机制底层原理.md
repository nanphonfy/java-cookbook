>java编译后成为字节码，被类加载器加载到JVM，最终需转化为汇编指令在CPU执行，其并发机制依赖于JVM和CPU指令。

### 1 volatile应用
>volatile是轻量级synchronized（多处理器保证共享变量的可见性），使用恰到时，比synchronized使用和执行成本更低（不会引起上下文切换和调度）。

#### 1.1 volatile定义与实现原理
>volatile定义：

- 实现原理相关的CPU术语和说明  

术语 | 描述
---|---
内存屏障| 一组处理器指令（限制内存操作顺序）
缓冲行 | 缓存最小存储单元
原子操作 | 不可中断的一个或一系列操作
缓存行填充| 识别到内存操作数可缓存，读取缓存行到适当缓存（L1、L2、L3或all）
缓存命中 | 缓存行填充的内存位置仍是下次处理器访问的，直接从缓存读
写命中 | 处理器将操作数写回，若缓存内存地址在缓存行（有效），则处理器写回缓存（而非内存）
写缺失 | 一个有效缓存行被写入不存在的内存区域

- volatile如何保证可见性
>其汇编代码的Lock前缀：  
>- ①将当前处理器缓存行数据写回系统内存（一般不锁总线，锁缓存[缓存锁定]）；
>- ②使其他CPU缓存该地址的数据无效（下次访问相同内存地址时，强制缓存行填充）。

为提升速度：处理器先将系统内存数据读到内部缓存（L1、L2...）。若对volatile变量写，JVM发送Lock前缀指令，将该变量所在缓存行写回到系统内存。  
>多处理器下，为保证各个处理器的缓存一致，实现缓存一致性协议。每个处理器嗅探总线传播的数据，检查缓存是否过期：若处理器发现缓存行的内存地址被修改，会把当前缓存行置无效，重新从系统内存读取。

#### 1.2 volatile的优化
- volatile使用优化
>追加字节能优化性能。一个对象引用占4字节，追加15个变量+父类一共64字节。因为对于很多处理器的L1、L2、L3缓存的高速缓存行是64字节宽，不支持部分填充缓存行（若队列头结点和尾结点都不足64行，可能会被读入同一个缓存行）。多处理器下都会缓存同样的头、尾节点，当一个处理器修改头结点时，将整个缓存行锁定，导致其他处理器不能访问自己高速缓存中的尾节点。且队列的出、入队需不停修改头、尾节点，多处理器下将严重影响性能。追加到64字节，避免了头结点和尾节点加载到同一个缓存行，头、尾不会互相锁定。

- 不适用场景
>①缓存行非64字节宽的处理器；  
②共享变量不会被频繁写（不频繁写，锁的概率很小，追加字节处理器需读更多字节到高速缓冲区，带来性能消耗）。

### 2 synchronized的实现原理与应用  
>java 1.6为减少synchronized获得锁和释放锁带来的性能消耗引入偏向锁和轻量级锁，及锁的存储结构和升级过程。

>- 同步基础：java每个对象都可作为锁。  
>>①普通同步方法（锁当前实例对象）；  
②静态同步方法（当前类的Class对象）；  
③同步方法块（锁synchronized口号里配置的对象）。

>JVM基于进入和退出monitor对象来实现方法同步和代码块同步。  
代码块同步使用monitorenter和monitorexit指令，方法同步使用其他方式（也可用这两指令实现）。

#### 2.1 java对象头
- java对象头的长度   

长度 | 内容| 说明
---|---|---
 32/64bit| mark word| 存储对象hashcode或锁信息
 32/64bit| class metadata address| 存储到对象类型数据的指针
 32/64bit| array length| 数组长度

- java对象头的存储结构    
>mark word默认存储对象的hashcode、分代年龄和锁标记位。

锁状态 | 25bit| 4bit| 1bit是否是偏向锁| 2bit锁标志位
---|---|---|---|---
 无锁状态| 对象的hashcode| 对象分代年龄 |0 |01 

- 32位mark word的状态变化  
>运行期间，mark word存储数据会随标志位变化而变化

锁状态 | 25bit| 4bit| 1bit是否是偏向锁| 2bit锁标志位
---|---|---|---|---
轻量级锁| 指向栈中锁记录的指针| | |00
重量级锁| 指向互斥量（重量级锁）的指针| | |10
GC标记| 空| | |11
偏向锁| 线程id、epoch| 对象分代年龄 |1 |01 

- 64位mark word的存储结构  

锁状态 | 25bit| 31bit| 1bit cms_free| 4bit 分代年龄| 1bit 偏向锁| 2bit 锁标志位
---|---|---|---|---|---|---
无锁| unused|hashcode | | | 0| 01
偏向锁| 线程id（54bit）、epoch（2bit）| | | |1 |01 

#### 2.2 锁的升级与对比
- 锁4种状态级别：  
`无锁<偏向锁<轻量级锁<重量级锁`    
为提高获得锁和释放锁的效率，锁升级不能降级。

- 偏向锁
>大多数情况，锁不存在多线程竞争，总由同一线程多次获得（引入偏向锁）。在对象头和栈帧的锁记录存储锁偏向的线程ID（进入和退出同步块不需进行CAS，只需判断mark word是否指向当前线程的偏向锁）。
>>成功，获得锁；失败，判断mark word偏向锁标志（1 偏向锁）:否，使用CAS竞争锁；是，CAS将对象头偏向锁指向当前线程。

>- 偏向锁撤销  
>等到竞争时才释放锁的机制，需等待该时间点无正在执行的字节码。  
①暂停拥有偏向锁的线程；②检查持有偏向锁的线程是否alive：not alive，将对象头设置->无锁状态；alive，拥有偏向锁的栈，遍历偏向对象的锁记录，栈中锁记录或对象头->重新偏向其他线程 or 恢复到无锁 or标记不适合作为偏向锁。最后，唤醒暂停线程。

>- 关闭偏向锁
偏向锁在jdk 1.6、1.7默认启用，在应用程序启动几秒后才激活，可用JVM参数关闭延迟。若所有锁通常都处于竞争状态，则可关闭锁（默认轻量级锁状态）。

线程1偏向锁初始化流程，线程2偏向锁撤销流程  
![image](https://github.com/nanphonfy/note-images/blob/master/java-cookbook/art-of-java-concurrency/02/biased_locking_process.png)

- 轻量级锁
>- ①轻量级锁加锁  
线程执行同步块前，JVM先在当前线程栈帧创建锁记录空间（并复制对象头的mark word），尝试CAS将对象头的mark word替换为指向锁记录指针。成功，获得锁；失败，其他线程获得锁，当前线程使用自旋获取锁。
>- ②轻量级锁解锁  
使用原子CAS将复制的mark word替换回对象头。成功，无竞争；失败，存在竞争，锁膨胀为重量级锁。  
>>自旋耗CPU，为避免无用自旋（被阻塞），一旦锁升级为重量锁，其他线程视图获取锁都会被阻塞，当持锁线程释放锁后唤醒这些线程（重新争夺锁）。

两线程同时争夺锁导致锁膨胀流程图  
![image](https://github.com/nanphonfy/note-images/blob/master/java-cookbook/art-of-java-concurrency/02/lightweight_locking_process)

- 锁的优缺点对比

锁状态 | 优点| 缺点| 适应场景
---|---|---|---
偏向锁| 加锁和解锁不需额外消耗，和非同步方法相当| 线程间的锁竞争带来额外的锁撤销消耗| 适用只有一个线程访问同步块场景
轻量级锁| 竞争线程不会阻塞，提高响应|若得不到锁竞争的线程，自旋消耗CPU| 追求响应，同步块执行非常快
重量级锁|线程竞争不使用自旋，不消耗CPU| 线程阻塞，响应时间慢| 追求吞吐，同步块执行速度较长

### 3. 原子操作实现原理 
>原子操作：不可被中断的一个或一系列操作。

#### 3.1 术语定义

术语名称 | 描述
---|---
缓存行| 缓存最小单位
比较并交换| CAS，需比较两值——旧值、新值，相等则不交换，否则交换成新值
CPU流水线|CPU由5~6个不同功能的电路单元组成一条指令处理流水线，然后分5、6步分别执行
内存顺序冲突|假共享，多个CPU同时修改同一缓存行的不同部分引起其中一个CPU操作无效（此时CPU必须清空流水线）

#### 3.2 处理器如何实现原子操作
>基于缓存加锁或总线加锁实现多处理器的原子操作。  
处理器会自动保证基本的内存操作的原子性，但复杂的内存操作处理器不能自动保证其原子性（eg.跨总线宽度、跨多个缓存行和跨页表的访问）

- 使用总线锁保证原子性
>若多个处理器同时对共享变量（X）读改写（i++），那么X会被多处理器同时操作（不是原子的），X值会和预期不一致。  
>>原因：多处理器同时从各自缓存中读X，分别加1，然后分别写入系统内存。    
方法：保证cpu1读改写X，cpu2不能操作缓存了该共享变量地址的缓存。  
总线锁：处理器提供LOCK#信号，当处理器在总线输出此信号，其他处理器请求被阻塞住，CPU即可独占共享内存。

- 缓存锁保证原子性
>同一时刻只需保证对某个内存地址操作的原子性，在某些场合使用开销较小的缓存锁进行优化。  
