>java编译后成为字节码，被类加载器加载到JVM，最终需转化为汇编指令在CPU执行，其并发机制依赖于JVM和CPU指令。

#### 1 volatile应用
>volatile是轻量级synchronized（多处理器保证共享变量的可见性），使用恰到时，比synchronized使用和执行成本更低（不会引起上下文切换和调度）。

##### 1.1 volatile定义与实现原理
>volatile定义：

- 实现原理相关的CPU术语和说明  

术语 | 描述
---|---
内存屏障| 一组处理器指令（限制内存操作顺序）
缓冲行 | 缓存最小存储单元
原子操作 | 不可中断的一个或一系列操作
缓存行填充| 识别到内存操作数可缓存，读取缓存行到适当缓存（L1、L2、L3或all）
缓存命中 | 缓存行填充的内存位置仍是下次处理器访问的，直接从缓存读
写命中 | 处理器将操作数写回，若缓存内存地址在缓存行（有效），则处理器写回缓存（而非内存）
写缺失 | 一个有效缓存行被写入不存在的内存区域

- volatile如何保证可见性
>其汇编代码的Lock前缀：  
>- ①将当前处理器缓存行数据写回系统内存（一般不锁总线，锁缓存[缓存锁定]）；
>- ②使其他CPU缓存该地址的数据无效（下次访问相同内存地址时，强制缓存行填充）。

为提升速度：处理器先将系统内存数据读到内部缓存（L1、L2...）。若对volatile变量写，JVM发送Lock前缀指令，将该变量所在缓存行写回到系统内存。  
>多处理器下，为保证各个处理器的缓存一致，实现缓存一致性协议。每个处理器嗅探总线传播的数据，检查缓存是否过期：若处理器发现缓存行的内存地址被修改，会把当前缓存行置无效，重新从系统内存读取。

##### 1.2 volatile的优化
- volatile使用优化
>追加字节能优化性能。一个对象引用占4字节，追加15个变量+父类一共64字节。因为对于很多处理器的L1、L2、L3缓存的高速缓存行是64字节宽，不支持部分填充缓存行（若队列头结点和尾结点都不足64行，可能会被读入同一个缓存行）。多处理器下都会缓存同样的头、尾节点，当一个处理器修改头结点时，将整个缓存行锁定，导致其他处理器不能访问自己高速缓存中的尾节点。且队列的出、入队需不停修改头、尾节点，多处理器下将严重影响性能。追加到64字节，避免了头结点和尾节点加载到同一个缓存行，头、尾不会互相锁定。

- 不适用场景
>①缓存行非64字节宽的处理器；
②共享变量不会被频繁写（不频繁写，锁的概率很小，追加字节处理器需读更多字节到高速缓冲区，带来性能消耗）。

### 2 synchronized的实现原理与应用  
